---
title: java_study
description: 学习java入门时做的笔记
date: 2025-12-05
categories:
    - Java
---

## 数据类型
### 基本数据类型：数据值存储在自己空间
1. 整数类型：byte、short、int、long  
整数在计算机中以补码形式存在，最高位为符号位  
   > byte&emsp;1字节  
short&emsp;2字节  
int&emsp;&emsp;4字节  
long&emsp;8字节   

2. 浮点类型：float、double  
3. 字符类型：char  
4. 布尔类型：boolean
### 引用数据类型：数据值存储在堆中，自己空间存储地址值
类、接口、数组
### 类型转换
小范围转大范围：高位补0，符号位扩展  
大范围转小范围：直接截取低位

## switch语句  
case穿透：执行case语句时，若未发现break，则顺序执行下一个case语句，直到发现break为止  
if和switch的各自应用场景：if一般用于对范围的判断，switch用于在有限个数据任选其一  
## 循环语句
### for和while的对比  
相同点：运行规则相同  
不同点：for循环一般用于知道循环次数或者循环范围，while循环一般用于不知道循环次数和范围，只知道循环的结束条件  
### continue和break  
continue：结束本次循环，进入下一次循环
break：结束整个循环
## 数组
### 静态初始化（指定初始化值）  
数据类型[] 数组名 = {元素1, 元素2, 元素3...  }
### 动态初始化（指定数组长度）
数据类型[] 数组名 = new 数据类型[数组长度];  
### 遍历数组  
for(数据类型 变量名 : 数组名){
    //使用变量名进行操作
}  
## 方法
### 方法的定义
1. 我要干什么？——方法体  
2. 我需要什么？——形参  
### 方法的基本内存原理  
栈：方法调用时进栈，执行结束时出栈（先进后出）  
堆：创建对象（new）时进堆，存储引用数据类型的值  
### 基本数据类型和引用数据类型的存储  
基本数据类型：数据值存储在自己的空间中（传递时传递数据）  
引用数据类型：数据值存储在堆中，自己空间中存储的是地址值（传递时传递地址）  
## 二维数组  
### 初始化
数据类型[ ][ ] 数组名 = new 数据类型[行数][列数];  
数据类型[ ][ ] 数组名 = { {元素1, 元素2}, {元素3, 元素4} }  
### 遍历
外循环：遍历二维数组获取每一个一维数组 （数组名[ ]获取一维数组地址）  
内循环：遍历一维数组获取每一个元素 （数组名[ ][ ]同时获取一维数组地址和元素）
## 面向对象  
### 类和对象的关系  
类是对象的模板，对象是类的具体体现  
### 成员变量和局部变量
成员变量：定义在类中，方法外，可以被类中的所有方法使用，默认初始化值  
局部变量：定义在方法中，只能被该方法使用，使用前必须初始化  
### 构造方法  
1. 方法名和类名相同  
2. 没有返回值类型  
3. 用于创建对象并初始化对象成员变量  
### 方法重载  
在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或参数类型不同即可  
### 就近原则和this关键字  
就近原则：在方法中使用变量时，优先使用局部变量，如果没有则使用成员变量  
this关键字的两种用法：  
1. 表示当前对象的引用，指向当前对象本身  
2. 在构造方法中，this(形参列表)表示调用本类中的另一个构造方法  

this的内存原理：this存储在栈中，指向堆中的当前对象，代表方法调用者的地址值
### JavaBean类（描述某类事物）  
1. 类是公共的（public）  
2. 有一个无参的公共构造方法  
3. 成员变量私有化（private）
### 对象的内存解析  
栈：存储局部变量和方法调用  
堆：存储对象实例和数组实例，对象和数组的地址值存储在栈中  
方法区：存储类信息、常量、静态变量、方法字节码  
### static关键字
#### 静态变量  
特点：被类的所有对象共享，随着类的加载而加载，优先于对象存在  
调用方式：类名.静态变量名 或 对象名.静态变量名
#### 静态方法  
特点：多用在测试类和工具类中   
调用方式：类名.静态方法名 或 对象名.静态方法名  
静态方法中不能使用非静态的成员变量和成员方法，非静态方法二者都可以使用，因为静态方法优先于对象存在，而非静态的成员变量和成员方法依赖于对象存在
### 工具类  
1. 提供静态方法，方便调用  
2. 构造方法私有化，避免创建对象

## 集合
### ArrayList
1. 动态数组，长度可变  
2. 存储有序的、可重复的数据  
3. 底层使用Object[]数组存储数据  

## 继承  
### 继承的基本概念
1. 子类继承父类，子类拥有父类的属性和方法，可以访问父类的非私有成员  
2. 继承方法：使用extends关键字实现继承  
3. 继承特点：单继承、多层继承  
   >单继承：Java中一个类只能有一个直接父类  
多层继承：子类继承父类，父类继承祖父类  
Object类：所有类都继承Object类  
4. 继承中成员变量访问特点：
   >就进原则：子类对象访问成员变量时，优先访问局部变量，再访问子类自己的成员变量，再查找父类的成员变量，直到Object类为止，整个是一个向上的查找过程
### super关键字  
表示父类对象的引用，指向父类对象本身  
   >在子类构造方法中，super(形参列表)表示调用父类的构造方法  
super.成员变量名：访问父类的成员变量  
super.成员方法名(实参列表)：访问父类的成员方法
### 方法重写（Override）  
1. 子类继承父类后，可以对父类的方法进行重新定义和实现  
2. 重写方法的方法名、参数列表、返回值类型必须和父类被重写的方法相同  
3. 重写方法的访问权限不能小于父类被重写的方法的访问权限  
4. 父类被重写的方法不能是private、final、static修饰的  
5. 重写方法中可以调用父类被重写的方法，使用super关键字实现  
### 多态
定义：父类引用指向子类对象   
使用：
   >创建对象时，使用父类创建子类对象；  
定义方法时，形参使用父类类型，可以传入所有子类对象 

特点：  
   >多态只能发生在继承关系中  
多态只能调用子类重写父类的方法，不能调用子类特有的方法  
多态的前提是有继承关系和方法重写
   
多态的体现：方法调用时，编译看左边，运行看右边;变量访问时，编译运行都看左边  
## 包  
包的作用：用于对类进行分类管理，避免类名冲突  
包的声明：package 包名;  声明在类的第一行  
包的导入：import 包名.类名; 或 import 包名.*;*表示导入包中所有类  
使用其他类的规则：  
   1. 使用同一个包中的类，不需要导包
   2. 使用java.lang包中的类，不需要导包
   3. 其他情况都需要导包  
   4. 使用两个包中的同名类，需要使用类的全限定名（包名.类名） 

## final关键字
### final修饰变量
1. 基本数据类型：变量值不可改变
2. 引用数据类型：引用地址不可改变，但对象的内容可以改变
### final修饰方法
表示该方法不能被重写
### final修饰类
表示该类不能被继承
## 静态代码块  
使用static关键字修饰，随着类的加载而执行，并且只执行一次  
作用：用于初始化类的信息
## 抽象类和抽象方法
### 抽象方法  
父类中的抽象方法，提取子类的共性，没有方法体，用于被子类重写
### 抽象类
* 抽象类不能实例化  
* 继承抽象类的子类必须重写父类中的所有抽象方法，除非子类也是抽象类  
* 抽象类可以有构造方法，用于子类创建对象时调用父类构造方法   
* 作用：强制让子类按照某种格式重写
## 接口
### 接口的定义
1. 使用interface关键字定义
2. 接口中只能定义常量和抽象方法
### 接口的作用  
1. 规范类的行为
2. 实现多继承，接口可以被多个子类实现
### 接口中的成员
1. 成员变量：只能是常量，默认修饰符public static final
2. 成员方法：只能是抽象方法，默认修饰符public abstract
### 接口的实现
1. 使用implements关键字实现接口
2. 格式：class 类名 implements 接口名1, 接口名2...{}
3. 实现接口的类必须重写接口中的所有抽象方法，除非该类是抽象类
### 接口和类之间的关系
* 类和类的关系：继承关系，只能单继承，不能多继承
* 类和接口的关系：实现关系，可以单实现，也可以多实现，可以在继承一个类的同时实现多个接口
* 接口和接口的关系：继承关系，可以单继承，也可以多继承
### 接口中新增的方法
#### 默认方法
* 使用default关键字修饰，可以有方法体，实现类不强制重写 
* 实现类可以重写接口中的默认方法，需要去掉default关键字
#### 静态方法
* 使用static关键字修饰，可以有方法体，实现类不能重写
* 只能通过接口名调用接口中的静态方法
#### 私有方法（Java 9及以上版本）
* 使用private关键字修饰
* 只能在接口内部使用，不能被实现类使用
## 内部类
### 成员内部类
#### 创建内部类对象：  
1. 外部类名.内部类名 对象名 = new 外部类名().new 内部类名();  
2. 在外部类的成员方法中创建内部类对象，外界通过外部类对象调用该方法获取内部类对象 
#### 内部类方法访问
1. 访问内部类成员：this.成员变量名 或 成员变量名
2. 访问外部类成员：外部类名.this.成员变量名
### 静态内部类
#### 创建静态内部类对象
外部类名.内部类名 对象名 = new 外部类名.内部类名();
#### 静态内部类方法访问
1. 访问静态方法：外部类名.内部类名.静态方法名();
2. 访问非静态方法：创建对象后，通过对象调用;  
### 匿名内部类
* 定义：没有类名的内部类，必须继承一个类或实现一个接口，继承类或实现接口的同时创建对象
* 作用：简化代码编写
* 格式：new 父类名或接口名(){重写父类或接口的方法};
## 集合框架
### collection接口
1. 是单列集合的顶层接口，所有方法被list和set接口继承
2. 常用方法：add()、remove()、clear()、size()、isEmpty()、contains()、toArray()
### List接口
1. 有序、可重复的集合
2. 常用实现类：ArrayList、LinkedList、Vector
3. 常用方法：add(index, element)、get(index)、set(index, element)、remove(index)、indexOf(element)、lastIndexOf(element)、subList(fromIndex, toIndex)
### Set接口
1. 无序、不可重复的集合
2. 常用实现类：HashSet、LinkedHashSet、TreeSet
3. HashSet：基于哈希表实现，存储元素无序
4. LinkedHashSet：基于哈希表和链表实现，存储元素有序
5. TreeSet：基于红黑树实现，存储元素有序
## 集合遍历
### 迭代器遍历
1. 用于遍历集合元素
2. 获取迭代器对象：Iterator<String> iterator = 集合对象.iterator();
3. 常用方法：hasNext()、next()、remove()  
hasNext() 判断当前指针是否有元素，next() 获取当前指向的元素并移动指针，remove() 删除当前元素
### 增强for遍历
1. 格式：for(数据类型 变量名 : 集合对象){ //使用变量名进行操作 }
2. 适用于所有实现了Iterable接口的集合类
### lamda表达式遍历
1. 格式：集合对象.forEach(变量名 -> { //使用变量名进行操作 });
2. 简化代码编写，提高可读性
## 数据结构
### 栈
1. 先进后出（LIFO）的数据结构
2. 主要操作：push()入栈，pop()出栈，peek()查看栈顶元素
### 队列
1. 先进先出（FIFO）的数据结构
2. 主要操作：offer()入队，poll()出队，peek()查看队头元素
### 数组
1. 由连续的内存空间组成的线性数据结构
2. 每个元素通过索引访问，查询操作高效，插入和删除操作较慢
### 链表
1. 由节点组成的线性数据结构，每个节点是独立的对象，在内存中不连续
2. 每个节点包含数据值和下一个节点的地址
2. 特点：插入和删除操作高效，查询操作较慢
## 泛型
### 集合中使用泛型
1. 定义：在集合类中使用泛型，可以指定集合中存储元素的类型
2. 格式：集合类<数据类型> 对象名 = new 集合类<>();
3. 细节：
   * 泛型只能是引用数据类型，不能是基本数据类型  
   * 指定泛型的类型后，传递数据时可以传入该类型及其子类类型对象
   * 如果不写泛型，默认类型为Object
### 泛型类
1. 定义：在类定义时使用泛型，可以指定类中成员变量和方法的参数类型
2. 格式：
   * 定义类时：class 类名<E>{ //类体 }，E表示不确定的类型
   * 创建对象时：类名<数据类型> 对象名 = new 类名<>();
### 泛型方法
1. 定义：在方法定义时使用泛型，可以指定方法的参数类型和返回值类型
2. 格式：
   * 定义方法时：<E> 返回值类型 方法名(E 参数名){ //方法体 }
   * 调用方法时：对象名.方法名(实参);
### 泛型接口
1. 定义：在接口定义时使用泛型，可以指定接口中方法的参数类型和返回值类型
2. 格式：
   * 定义接口时：interface 接口名<E>{ //接口体 }
   * 实现接口的两种方式：
       - 实现类给出具体的类型：class 类名 implements 接口名<数据类型>{ //类体 }
       - 实现类继续使用泛型：class 类名<E> implements 接口名<E>{ //类体 }















